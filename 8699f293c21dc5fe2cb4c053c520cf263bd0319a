{
  "comments": [
    {
      "key": {
        "uuid": "5c64320a_bf1dd871",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1143760
      },
      "writtenOn": "2016-10-13T18:13:56Z",
      "side": 1,
      "message": "We should only do this if we know the value of %ebx. Otherwise, we’ll be populating the postfix evaluator with garbage, and garbage in, garbage out.\n\nWe can do provide %ebx here when we’re trying to backtrack from the context frame (line 128 above), or when we know that we have recovered a valid %ebx value based on prior recovery from a PDB program string or DWARF CFI (see the chunk beginning at line 489 below). Check last_frame-\u003econtext_validity \u0026 CONTEXT_VALID_EBX.",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cf21ee7_afc1b9fc",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1144260
      },
      "writtenOn": "2016-10-13T18:47:03Z",
      "side": 1,
      "message": "Hmm, I wondered about that. The problem then is that the top two stack frames use the non-EBP-using artificial program string from here: https://cs.chromium.org/chromium/src/breakpad/src/processor/stackwalker_x86.cc?rcl\u003d0\u0026l\u003d317 . It doesn\u0027t explicitly say \"ebx_new \u003d ebx_old\", so we don\u0027t treat the value of EBX as valid by the time we\u0027ve come down the stack through a couple of those.\n\nI\u0027m not sure what we should do here. We don\u0027t know that EBX hasn\u0027t been modified. It\u0027s non-volatile across calls, but we don\u0027t have a way of knowing that it hasn\u0027t been saved and modified during the body of the function.\n\nWe could attempt to disassemble and scan for modifications to ebx from the function entry point to the EIP for the frame, I guess. That would work for this particular stack and likely many ntdll calls (as they\u0027re often simple forwards to kernel), but it\u0027s pretty tricksy.",
      "parentUuid": "5c64320a_bf1dd871",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcf16614_3dad2f88",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1143760
      },
      "writtenOn": "2016-10-13T22:20:18Z",
      "side": 1,
      "message": "\u003e Hmm, I wondered about that. The problem then is that the top two stack frames use the\n\u003e non-EBP-using artificial program string from here:\n\u003e https://cs.chromium.org/chromium/src/breakpad/src/processor/stackwalker_x86.cc?rcl\u003d0\u0026l\u003d317 .\n\u003e It doesn\u0027t explicitly say \"ebx_new \u003d ebx_old\", so we don\u0027t treat the value of EBX as valid by\n\u003e the time we\u0027ve come down the stack through a couple of those.\n\nOh, this is a mess, then.\n\nIs there anything else that DIA can tell us about whether ebx is untouched that we can expose via dump_syms? There may be some useful information in the .pdb that we’re missing, like an “I don’t touch %ebp” bit. Maybe we can make that leap based on IDiaFrameData::get_type()?\n\n(Looking at the DIA docs today, I see that they’ve gotten slightly better. Ten years ago, the format of “program string” wasn’t explained at all.)\n\n\u003e We could attempt to disassemble and scan for modifications to ebx from the function entry\n\u003e point to the EIP for the frame, I guess.\n\nUgh, I don’t want to go down that road.",
      "parentUuid": "3cf21ee7_afc1b9fc",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c899276_b37ee201",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1144260
      },
      "writtenOn": "2016-10-13T22:32:12Z",
      "side": 1,
      "message": "\u003e Ugh, I don’t want to go down that road.\n\nYeah, I wrote the code to walk the disassembly in the stackwalker which wasn\u0027t too bad (since we have libdis already nearby), but then I realized that of course we won\u0027t naturally or normally have the code bytes for, say, ntdll.dll.\n\n... I wonder if windbg walks the stack correctly without the dll file. I will test that.\n\nI will also have a look into DIA\u0027s data. I suspect get_type() is about as good as just adding \"$ebx $ebx \u003d\" to the end of the non-EBP-using program string.",
      "parentUuid": "fcf16614_3dad2f88",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fcf16614_1ddcb303",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1143760
      },
      "writtenOn": "2016-10-13T22:39:56Z",
      "side": 1,
      "message": "\u003e Yeah, I wrote the code to walk the disassembly in the stackwalker which wasn\u0027t too bad (since\n\u003e we have libdis already nearby), but then I realized that of course we won\u0027t naturally or\n\u003e normally have the code bytes for, say, ntdll.dll.\n\nOr anything else, for that matter. The crash processor only has dumped sym files, not pdbs or code.\n\nWe’d have to disassemble (everything?) at dump_syms time, which is also pretty not great.\n\n\u003e I will also have a look into DIA\u0027s data. I suspect get_type() is about as good as just adding\n\u003e \"$ebx $ebx \u003d\" to the end of the non-EBP-using program string.\n\nYeah, I was thinking that if there are certain frame types where we’ll know that this would always be valid, we could just append that tweak to the program string in those cases. That would let us fix this without a breaking dump_syms format change.",
      "parentUuid": "5c899276_b37ee201",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c899276_33619232",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1144260
      },
      "writtenOn": "2016-10-13T22:42:49Z",
      "side": 1,
      "message": "\u003e ... I wonder if windbg walks the stack correctly without the dll file. I will test that.\n\nIt does work OK. That could be because it just passes through EBX even if it doesn\u0027t have information on the correctness of doing so though. Presumably (?) a subframe wouldn\u0027t use it as part of its stackwalking program if it didn\u0027t know it was safe to do so.",
      "parentUuid": "5c899276_b37ee201",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5c899276_73407a8c",
        "filename": "src/processor/stackwalker_x86.cc",
        "patchSetId": 1
      },
      "lineNbr": 210,
      "author": {
        "id": 1144260
      },
      "writtenOn": "2016-10-13T22:44:26Z",
      "side": 1,
      "message": "\u003e \u003e Yeah, I wrote the code to walk the disassembly in the stackwalker which wasn\u0027t too bad (since\n \u003e \u003e we have libdis already nearby), but then I realized that of course we won\u0027t naturally or\n \u003e \u003e normally have the code bytes for, say, ntdll.dll.\n \u003e \n \u003e Or anything else, for that matter. The crash processor only has dumped sym files, not pdbs or code.\n \u003e \n \u003e We’d have to disassemble (everything?) at dump_syms time, which is also pretty not great.\n\nI was thinking we had some of the memory in the minidump that we could use. We do have the memory around EIP at crash time, but not around the return address.\n\n \u003e \n \u003e \u003e I will also have a look into DIA\u0027s data. I suspect get_type() is about as good as just adding\n \u003e \u003e \"$ebx $ebx \u003d\" to the end of the non-EBP-using program string.\n \u003e \n \u003e Yeah, I was thinking that if there are certain frame types where we’ll know that this would always be valid, we could just append that tweak to the program string in those cases. That would let us fix this without a breaking dump_syms format change.",
      "parentUuid": "fcf16614_1ddcb303",
      "revId": "8699f293c21dc5fe2cb4c053c520cf263bd0319a",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": false
    }
  ]
}